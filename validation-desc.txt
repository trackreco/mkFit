This file is a compendium on how the validation runs within mkFit, which makes use of the TTreeValidation class and other supporting macros.  

Table of Contents

A. Overview of code
B. Overview of routine calls in mkFit
C. Explanation of validation routines
  I. Tracks and Extras Prep
  II. Track Association Routines
  III. TTree Filling
D. Definitions of efficiency, fake rate, and duplicate rate
E. Overview of scripts
F. Hit map/remapping logic
G. Extra info on ID and mask assignments
H. Special note about duplicate rate
I. The use of label_

=====================
 A. Overview of code
=====================

TTreeValidation will only compile the necessary ROOT code with WITH_ROOT=yes enabled (either manually editting Makefile.config, or at the command line). Always do a make clean before compiling with ROOT, as the code is ifdef'ed. To hide the heavy-duty functions from the main code, TTreeValidation inherits from the virtual class "Validation", and overrides the common functions.  The TTreeValidation object is created once per number of events in flight. The Event object obtains a reference to the validation object (store as a data member "validation_"), so it is up to the Event object to reset some of the data members of the TTreeValidation object on every event.

Three types of validation exist within TTreeValidation:
[1.] "Building validation", enabled with Config::root_val, via the command line option: --root-val [--read-sim-trackstates, for pulls]
[2.] "CMSSW external tracks building validation", enabled with Config::cmssw_val, via a minimum of the command line options: --cmssw-val --read-cmssw-tracks --geom CMS-2017 --seed-input cmssw [and potentially a seed cleaning --seed-cleaning <str>, and also specifying which cmssw matching --cmssw-matching <str>]
[3.] "Fit validation", enabled with Config::fit_val, via the command line option: --fit-val

We will ignore fit validation for the moment. The main idea behind the other two is that the validation routines are called outside of the standard timed sections, and as such, we do not care too much about performance, as long as it takes a reasonable amount of time to complete. Of course, the full wall clock time matters when running multiple events in flight, and because there is a lot of I/O as well as moves and stores that would hurt the performance with the validation enabled, these routines are ignored if the command line option "--silent" is enabled.

The building validation takes advantage of filling two trees per event per track, namely:
[1.] 
  - efftree (filled once per sim track) 
  - frtree (filled once per seed track)
[2.] 
  - cmsswefftree (filled once per cmssw external track)
  - cmsswfrtree (filled once per mkFit build track)

[1.] validation exists in the following combinations of geometry seed source:
  - ToyMC, with --seed-input ["sim", "find]
  - CMSSW, with --seed-input ["sim", "cmssw"] (+ --seed-cleaning <str> [<str>: "n2", "badlabel", "pure", "none"], + --cmssw-matching <str> [<str>: "trkparam", "hit", "label"])

Upon instantiation of the TTreeValidation object, the respective ROOT trees are defined and allocated on the heap, along with setting the addresses of all the branches. After the building is completed in mkFit, we have to have the tracks in their standard event containers, namely: seedTracks_, candidateTracks_, and fitTracks_. In the standard combinatorial or clone engine, we have to copy out the built tracks from event of combined candidates into candidateTracks_ via: builder.quality_store_tracks() in mkFit/buildtestMPlex.cc.  Since we do not yet have fitting after building, we just set the fitTracks_ equal to the candidateTracks_.  For ease, I will from now on refer to the candidateTracks_ as buildTracks_.

As a reminder, the sim tracks are stored in the Event.cc as simTracks_, while the CMSSW reco tracks are stored as cmsswTracks_. Each track collection has an associated TrackExtra collection, which is stored as {trackname}Extra_ inside the Event object.  It is indexed the same as the collection it references, i.e. track[0] has an associated extra extra[0]. The TrackExtra object contains the mcTrackID, seedID, and cmsswTrackID each mkFit track is associated to. The validation also makes use of simHitsInfo_ (container for storing mcTrackID for each hit), layerHits_, and simTrackStates_ (used for pulls).  See Section B and C for explanations on how the track matching is performed and track information is saved.  Essentially, we store two sets of maps, one which has a key that is an index to the reference track (MC or CMSSW) and a vector of indices for those that match it (for seeds, build tracks, and fit tracks), and the second map which maps the seed track index to its corresponding build and fit tracks.  The reason for having a sim match map for seeds, build tracks, and fit tracks is to keep track of how well the efficiency/fake rate/duplicate improves/degrades with potential cuts between them. And the same reason for having a map of seed to build as well as seed to fit. 

Following each event, each of the track and extra objects are cleared. In addition, the association maps are cleared and reset. After the main loop over events expires, the ROOT file is written out with the TTrees saved via: val.saveTTrees() in mkFit.cc. The destructor for the validation then deletes the trees. The output is "valtree.root", appended by the thread number if using multiple events in flight.  From here, we then take advantage of the following files:

- runValidation.C // macro used for turning TTrees into efficiency/fake rate/duplicate rate plots
- PlotValidation.cpp/.hh // source code for doing calculations
- makeValidation.C // plots on a single canvas results for Best Hit (BH), Standard Combinatorial (STD), and Clone Engine (CE)

======================================
 B. Outline of routine calls in mkFit
======================================

The following routines are then called after the building (MkBuilder.cc, Event.cc, TTreeValidation.cc, Track.cc):

[1.] builder.root_val()
   : (actually run clean_cms_simtracks() when using CMS geom and using sim tracks as reference set)
   : remap_seed_hits()
   : remap_cand_hits()
   : prep_recotracks()
     : prep_tracks(seedtracks,seedextras)
       : m_event->validation_.alignTracks(tracks,extras,false)
     : prep_tracks(buildtracks,buildextras)
       : m_event->validation_.alignTracks(tracks,extras,false)
     : prep_tracks(fittracks,fitextras)
       : m_event->validation_.alignTracks(tracks,extras,false)
   : if (cmssw-seeds) m_event->clean_cms_simtracks() // label which simtracks are not findable: already set if using sim seeds
   : m_event->Validate()
     : validation_.setTrackExtras(*this) 
       : if (sim seeds) extra.setMCTrackIDInfoByLabel() // Require 50% of found hits after seed to match label of seed/sim track
         : modifyRecTrackID()
       : if (--seed-input cmssw || find) extra.setMCTrackIDInfo() // Require 75% of found hits to match a single sim track
         : modifyRecTrackID()
     : validation_.makeSimTkToRecoTksMaps(*this)
       : mapRefTkToRecoTks(seedtracks,seedextras,simToSeedMap) // map key = mcTrackID, map value = vector of seed labels
       : mapRefTkToRecoTks(buildtracks,buildextras,simToBuildMap) // map key = mcTrackID, map value = vector of build labels
       : mapRefTkToRecoTks(fittracks,fitextras,simToFitMap) // map key = mcTrackID, map value = vector of fit labels
     : validation_.makeSeedTkToRecoTkMaps(*this)
       : mapSeedTkToRecoTk(buildtracks,buildextras,seedToBuildMap) // map key = seedID, map value = build track label
       : mapSeedTkToRecoTk(fittracks,fitextras,seedToFitMap) // map key = seedID, map value = fit track label
     : validation_.fillEfficiencyTree(*this)
     : validation_.fillFakeRateTree(*this)	

[2.] builder.cmssw_val()
   : (actually runs m_event->validation.makeSeedTkToCMSSWTkMap() from MkBuilder::prepare_seeds())
   : (when using N^2 cleanings, Event::clean_cms_seedtracks(), or if not using N^2 cleaning, Event::use_seeds_from_cmsswtracks())
   : remap_cand_hits()
   : prep_recotracks()
     : prep_tracks(buildtracks,buildextras)
       : m_event->validation_.alignTracks(tracks,extras,false)
   : prep_cmsswtracks()
     : prep_tracks(cmsswtracks,cmsswextras)	
       : m_event->validation_.alignTracks(tracks,extras,false)	
   : m_event->Validate()
     : validation_.setTrackExtras(*this)
       : storeSeedAndMCID() 
       : if (--cmssw-matching trkparam) extra.setCMSSWTrackIDInfoByTrkParams() // Chi2 and dphi matching (also incudes option for nHits matching)
    	 : modifyRecTrackID()		      
       : else if (--cmssw-matching hit) extra.setCMSSWTrackIDInfoByHits() // Chi2 and dphi matching (also incudes option for nHits matching)
    	 : modifyRecTrackID()		      
       : else if (--cmssw-matching label) extra.setCMSSWTrackIDInfoByLabel() // 50% hit sharing after seed
    	 : modifyRecTrackID()		      
     : validation_.makeCMSSWTkToRecoTksMaps(*this)
       : mapRefTkToRecoTks(buildtracks,buildextras,cmsswToBuildMap)
     : validation_.fillCMSSWEfficiencyTree(*this)	
     : validation_.fillCMSSWFakeRateTree(*this)	

=======================================
 C. Explanation of validation routines
=======================================

- map/remap hit functions: see notes in section E. Essentially, validation needs all hit indices inside tracks to match the hit indices inside ev.layerHits_.

+++++++++++++++++++++++++++
 I. Tracks and Extras Prep
+++++++++++++++++++++++++++

- clean_cms_simtracks()
  : loop over sim tracks
    : mark sim track status not findable if (nLayers < [Config::cmsSelMinLayers == 8])
    : tracks are not removed from collection, just have this bit set. this way the mcTrackID == position in vector == label

- clean_cms_seedtracks()
  : cmssw seed tracks are cleaned according to closeness in deta, dphi, dR to other cmssw seed tracks--> duplicate removal
  : loop over cleaned seed tracks, and if label_ == -1, then incrementally decrease label (so second -1 seed is -2, third is -3)

- prep_tracks(tracks,extras) 
  : Loop over all track collections in consideration
    : sort hits inside track by layer : needed for counting unique layers and for association routines
    : emplace_back a track extra, initialized with the label of the track (which happens to be its seed ID) // if using sim seeds, we know that seed ID == sim ID
  : m_event->validation_.alignTracks(tracks,extras,alignExtra)   

- alignTracks(tracks,extras,alignExtra)
  : if alignExtra == true // needed for when a reco track collection, which was previously labeled by its label() == seedID, created its track extra at the same time but the track collection has been moved or sorted
    : create temporary track extra collection, size of track collection
    : loop over tracks
      : set tmp extra to the old track extra collection matching the track label
    : set the old track extra to equal the new collection
  : loop over tracks
    : set the track label equal to the index inside the vector // needed for filling routines which rely on maps of indices between two track collections

- prep_cmsswtracks()
  : Stanard prep_tracks()
  : loop over cmssw tracks
    : Count unique layers = nLayers
    : set status of cmssw track to notFindable() if: (nUniqueLayers() < [Config::cmsSelMinLayers == 8]) // same criteria for "notFindable()" cmssw sim tracks used for seeds

++++++++++++++++++++++++++++++++
 II. Track Association Routines
++++++++++++++++++++++++++++++++

- setTrackExtras(&Event)    
  : if [1.]
    : loop over seed tracks
      : setMCTrackIDInfo(true) : Require 75% of found hits to match a single sim track
    : loop over build tracks
       : if (sim seeds) setMCTrackIDInfoByLabel() : Require 50% of found hits after seed to match label of seed/sim track
       : if (cms seeds) setMCTrackIDInfo(false) : Require 75% of found hits to match a single sim track
    : loop over fit tracks 
      : same options as build tracks   
  : if [2.]
    : setupCMSSWMatching()
      : first loop over cmssw tracks
        : create a vector of "reduced tracks" that stores 1./pt, eta, and associated covariances in reduced track states
        : add cmssw label to a map of lyr, map of idx, vector of labels
        : also include track momentum phi, and a list of hits inside a map. map key = layer, map value = vector of hit indices
    : loop over build tracks
      : setCMSSWTrackIDInfo() : require matching by chi2 and dphi
    : storeMCandSeedID()

- modifyRecTrackID() 
  // Config::nMinFoundHits = 7, Config::nlayers_per_seed = 4 or 3 
  // nCandHits = trk.nFoundHits() OR trk.nFoundHits()-Config::nlayers_per_seed (see calling function)
  // nMinHits = Config::nMinFoundHits OR Config::nMinFoundHits-Config::nlayers_per_seed (see calling function)
  : if (mc/cmsswTrackID >= 0) (i.e. the track has successfully matched)
    : if mc/cmsswTrack is findable
      : if nCandHits < nMinHits, mc/cmsswTrackID = -2
    : else
      : if nCandHits < nMinHits, mc/cmsswTrackID = -3 
      : else mc/cmsswTrackID = -4 (track is long enough, matched, but that sim track that is unfindable)
  : else if (mc/cmsswTrackID == -1)
    : if matching by label, and ref track exists
      : if ref track is findable
        : if nCandHits < minHits, ID = -5
      : else 
        : if nCandHits < nMinHits, ID = -6
	: else, ID = -7
    : else (not matching by label, or ref track does not exist
      : if nCandHits < nMinHits, ID = -8
      : else, ID = -9
  : else if (mc/cmsswTrackID == -10), i.e. track is a pure seed and we are matching using byLabel
    : if ref track exists
      : if nCandHits < nMinHits, ID = -11
      : else, ID = -12
  -->return potentially new ID assignment

- setMCTrackIDInfoByLabel()
  : Loop over found hits on build track after seed
    : count the hits who have a mcTrackID == seedID_ (i.e. seedID == simTrack label == mcTrackID)
  : if hits are found after seed
    : if 50% are matched, mcTrackID == seedID_
    : else, mcTrackID == -1
  : else 
    : mcTrackID = -10
  : mcTrackID = modifyRecTrackID() // nCandhits = nFoundHits-nlayers_per_seed, nMinHits = Config::nMinFoundHits - Config::nlayers_per_seed		      
    
- setMCTrackIDInfo(isSeedTrack)
  : if track somehow has zero hits on track, mcTrackID = -13 --> should never happen unless some really deep bug
  : Loop over all found hits on build track (includes seed hits)
    : count the mcTrackID that appears most from the hits
  : if 75% of hits on reco track match a single sim track, mcTrackID == mcTrackID of single sim track
  : else, mcTrackID == -1
  : if (!isSeedTrack)
    : modifyRecTrackID() // nCandHits = nFoundHits, nMinHits = Config::nMinFoundHits

- setCMSSWTrackIDInfo()
  : Loop over all cmssw "reduced" tracks
    : if helix chi2 < [Config::minCMSSWMatchChi2 == 50]
      : append label of cmssw track to a vector, along with chi2
  : sort vector by chi2
  : loop over label vector
    : swim cmssw track momentum phi from phi0 to mkFit reco track
    : if abs(wrapphi(dphi)) < [Config::minCMSSWMatchdPhi == 0.03]
      : see if dphi < currently best stored mindphi, and if yes, then set this as the new mindphi + label as matched cmsswTrackID
      : if using nHits matching, check for nHits matched --> currently not used nor tuned
  : if no label is found, cmsswTrackID == -1
  : modifyRefTrackID() // nCandHits and nMinHits same as setMCTrackIDInfo()

- setCMSSWTrackIDInfoByLabel()
  : want to match the hits on the reco track to those on the CMSSW track
  : loop over hits on reco track after seed
    : get hit idx and lyr
      : if the cmssw track has this lyr, loop over hit indices on cmssw track with this layer
        : if cmssw hit idx matches reco idx, increment nHitsMatched_
  : follow same logic as setMCTrackIDInfoByLabel() for setting cmsswTrackID
  : modifyRecTrackID() // nCandHits and nMinHits same as setMCTrackIDInfoByLabel()
  
- mapRefTkToRecoTks(tracks,extras,map)
  : Loop over reco tracks
    : get track extra for track
    : if [1.], map[extra.mcTrackID()].push_back(track.label()) // reminder, label() now equals index inside track vector!
    : if [2.], map[extra.cmsswTrackID()].push_back(track.label()) // reminder, label() now equals index inside track vector!
  : Loop over pairs in map
    : if vector of labels size == 1, get track extra for label, and set duplicate index == 0
    : else
      : make temp track vector from track labels, sort track vector by nHits (and sum hit chi2 if tracks have same nHits)
      : set vector of labels to sorted tracks
      : loop over vector labels
      	: get track extra for label, and set duplicate index++ 

- mapSeedTkToRecoTk(tracks,extras,map)
  : loop over reco tracks
    : map[extra.seedID()] = track.label()

- makeSeedTkToCMSSWTkMap(event)
  : this is run BEFORE seed cleaning AND BEFORE the seeds are sorted in eta in prepare_seeds()
  : if seed track index in vector == cmssw track label(), store map key = seed track label(), map value = cmssw track label() in seedToCmsswMap (seedID of cmssw track)

- storeMCandSeedID()
  : reminder: both the candidate tracks and the cmssw tracks have had their labels reassigned, but their original labels were stored in their track extra seedIDs.  reminder, seedID of candidate track points to the label of the seed track.  label on seed track == sim track reference, if it exists!
  : loop over candidate tracks
    : set mcTrackID == seedID_ of track
    : if seedToCmsswMap[cand.label()] exists, then set the seedID equal to the mapped value (i.e. the seedID of the cmssw track!)
    : else, set seedID == -1
  : After this is run, to get the matching CMSSW track, we then need to loop over the CMSSW track extras with an index based loop, popping out when the cmsswextra[i].seedID() == buidextra[j].seedID()

++++++++++++++++++++
 III. TTree Filling
++++++++++++++++++++

- fillEfficiencyTree()
  : loop over simtracks
    : get mcTrackID (i.e. simTrack.label())
    : store sim track gen info
    : if simToSeedMap[mcTrackID] has value
      : mcmask == 1
      : get first seed track matched (i.e. the one with the highest nHits --> or lowest sum hit chi2 as provided by sort from above)
      : store seed track parameters
      : store nHits, nlayers, last layer, chi2
      : store duplicate info: nTrks_matched from size() of mapped vector of labels, and duplicateMask == seedtrack.isDuplicate()
      : get last found hit index
      	: store hit parameters
	: if mcTrackID of hit == mcTrackID of sim track // ONLY for when simtrackstates are stored, i.e. in ToyMC only at the moment
	  : store sim track state momentum info from this layer (from simTrackStates[mcHitID])
	: else get sim track state of mcTrackID, then store momentum info
    : else
      : mcmask == 0, or == -1 if simtrack.isNotFindable()
    : if simToBuildMap[mcTrackID] has value
      : repeat as above
    : if simToFitMap[mcTrackID] has value
      : repeat as above
    : fill efftree

- fillFakeRateTree()
  : loop over seed tracks
    : get seedID of seed track from track extra
    : fill seed track parameters + last hit info, nhits, etc
    : assign mcmask info based on mcTrackID from track extra (see section D and G for explanation of mask assignments)
    : if mcmask == 1
      : store gen sim momentum parameters
      : store nhits info, last layer
      : store duplicate info: iTh track matched from seedtrack extra, duplicateMask == seedtrack.isDuplicate()
      : if last hit found has a valid mcHitID
      	: store sim track state momentum info from simTrackStates[mcHitID]
    : if seedToBuildMap[seedID] has value
      : fill build track parameters + last hit info, nhits, etc
      : assign mcmask info based on mcTrackID from track extra (see section D and G for explanation of mask assignments)
      : if mcmask == 1
      	: store gen sim momentum parameters
        : store nhits info, last layer, duplicate info as above
        : if last hit found has a valid mcHitID
      	  : store sim track state momentum info from simTrackStates[mcHitID]
    : if seedToFitMap[seedID] has value
      : same as above
    : fill frtree

- fillCMSSWEfficiencyTree()
  : loop over cmsswtracks
    : get label of cmsswtrack, seedID
    : store cmssw track PCA parameters + nhits, nlayers, last layer
    : if cmsswToBuilddMap[cmsswtrack.label()] has value
      : get first build track matched (i.e. the one with the highest nHits --> or lowest sum hit chi2 as provided by sort from above)
      : store build track parameters + errors
      : store nHits, nlayers, last layer, last hit parameters, hit and helix chi2, duplicate info, seedID
      : swim cmssw phi to mkFit track, store it
    : fill cmsswefftree

- fillCMSSWFakeRateTree()
  : loop over build tracks
    : store build track parameters + errors
    : store nHits, nlayers, last layer, last hit parameters, hit and helix chi2, duplicate info, seedID
    : get cmsswTrackID, assign cmsswmask according to section D and G
    : if cmsswmask == 1 
      : store cmssw track PCA parameters + nhits, nlayers, last layer, seedID
      : swim cmssw phi to mkFit track, store it
    : fill cmsswefftree

=============================================================
 D. Definitions of efficiency, fake rate, and duplicate rate
=============================================================

Use rootValidation.C to create efficiency, fake rate, and duplicate rate vs. pT, phi, eta. This macro compiles PlotValidation.cpp/.hh. Efficiency uses sim track momentum info. Fake rate uses the reco track momentum. For [1.], plots are made for seed, build, and fit tracks. For [2.], the plots are only against the build tracks. See G. for more details on ID assignments.

root -l -b -q runValidation.C\([agruments]\)

Argument list: 
First is additional input name of root file [def = ""]
Second argument is boolean to compute momentum pulls: currently implemented only when sim track states are available (ToyMC validation only)! [def = false]
Third argument is boolean to do special CMSSW validation [def = false]
Fourth argument == true to move input root file to output directory, false to keep input file where it is. [def = true]
Fifth argument is a bool to save the image files [def = false]
Last argument is output type of plots [def = "pdf"]

Efficiency [PlotValidation::PlotEfficiency()]
  numerator:   sim tracks with at least one reco track with mcTrackID >= 0 (mcmask_[reco] == 1)
  denominator: all findable sim tracks (mcmask_[reco] = 0 || == 1)
  mcmask_[reco] == - 1 excluded from both numerator and denominator because this sim track was not findable!

Fake Rate (with only long reco tracks: Config::inclusiveShorts == false) [PlotValidation::PlotFakeRate()]
  numerator:   reco tracks with mcTrackID == -1 || == -9
  denominator: reco tracks with mcTrackID >=  0 || == -1 || == -9
  mcTrackID | mcmask_[reco] 
     >= 0   |     1
    -1,-9   |     0
     else   |    -1 // OR the seed track does produce a build/fit track as determined by the seedToBuild/FitMap

Fake Rate (with all reco tracks: Config::inclusiveShorts == true, enabled with command line option: --inc-shorts) [PlotValidation::PlotFakeRate()]
  numerator:   reco tracks with mcTrackID == -1 || == -5 || ==  -8 || ==  -9
  denominator: reco tracks with mcTrackID >=  0 || == -2 || == -10 || == -11 || == -1 || == -5 || == -8 || == -9
  mcTrackID  | mcmask_[reco] 
    >= 0     |     1
 -1,-5,-8,-9 |     0
 -2,-10,-11  |     2   
    else     |    -1 // OR the seed track does produce a build/fit track as determined by the seedToBuild/FitMap

Duplicate Rate [PlotValidation::PlotDuplicateRate()], see special note in section H
  numerator:   sim tracks with more than reco track match (duplmask_[reco] == 1), or another way is nTrks_matched_[reco] > 1
  denominator: sim tracks with at least one reco track with mcTrackID >= 0 (duplmask_[reco] != -1), or mcmask_[reco] == 1

========================
 E. Overview of scripts
========================

I. ./validation-snb-toymc-fulldet-build.sh
Runs ToyMC full detector tracking for BH, STD, CE, for 400 events with nTracks/event = 2500. Sim seeds only.

To move the images + text files and clean up directory:
./web/move-toymcval.sh ${outdir name}

II. ./validation-snb-cmssw-10mu-fulldet-build.sh
Runs CMSSW full detector tracking for BH, STD, CE, for ~1000 events with 10 muons/event, with sim and cmssw seeds, using N^2 cleaning for cmssw seeds.
Samples are split by eta region. Building is run for each region:
- ECN2: 2.4 < eta < 1.7
- ECN1: 1.75 < eta < 0.55
- BRL: |eta| < 0.6
- ECP1: 0.55 < eta < 1.75
- ECP2: 1.7 < eta < 2.4

Validation plots are produced for each sample (region), seeding source, and building routine. At the very end, validation trees are hadd'ed for each region in a given seed source + building routine. Plots are produced again to yield "full-detector" tracking.

To move the images + text files and clean up directory:
./web/move-cmsswval-10mu.sh ${outdir name}

III. ./validation-snb-cmssw-10mu-fulldet-extrectracks.sh
Same as II., but now only run with cmssw seeds (as we are comparing directly to cmssw output as the reference).

To move the images + text files and clean up directory:
./web/move-cmsswval-10mu-extrectracks.sh ${outdir name}

IV. ./validation-snb-cmssw-ttbar-fulldet.sh
Runs CMSSW full detector tracking for BH, STD, CE, for three different ttbar samples with 100 events each, with sim and cmssw seeds, using N^2 cleaning for cmssw seeds.
TTbar samples:
- No PU
- PU 35
- PU 70

To move the images + text files and clean up directory:
./web/move-cmsswval-ttbar.sh ${outdir name}

V. ./validation-snb-cmssw-ttbar-fulldet.sh
Same as IV., but now only run with cmssw seeds, using cmssw rec tracks as the reference set of tracks.

To move the images + text files and clean up directory:
./web/move-cmsswval-ttbar-extrectracks.sh ${outdir name}

============================
 F. Hit map/remapping logic
============================

*** Originally from mkFit/MkBuilder.cc ***

All built candidate tracks have all hit indices pointing to m_event_of_hits.m_layers_of_hits[layer].m_hits (LOH)
MC seeds (both CMSSW and toyMC),as well as CMSSW seeds, have seed hit indices pointing to global HitVec m_event->layerHits_[layer] (GLH)
Found seeds from our code have all seed hit indices pointing to LOH.
So.. to have universal seed fitting function --> have seed hits point to LOH no matter their origin.
This means that all MC and CMSSW seeds must be "mapped" from GLH to LOH: map_seed_hits().
Now InputTracksAndHits() for seed fit will use LOH instead of GLH.
The output tracks of the seed fitting are now stored in m_event->seedTracks_.

Then building proceeds as normal, using m_event->seedTracks_ as input no matter the choice of seeds. 

For the validation, we can reuse the TrackExtra setMCTrackIDInfo() with a few tricks.
Since setMCTrackIDInfo by necessity uses GLH, we then need ALL track collections (seed, candidate, fit) to their hits point back to GLH.
There are also two validation options: w/ or w/o ROOT.

W/ ROOT uses the TTreValidation class which needs seedTracks_, candidateTracks_, and fitTracks_ all stored in m_event.
The fitTracks_ collection for now is just a copy of candidateTracks_ (eventually may have cuts and things that affect which tracks to fit).
So... need to "remap" seedTracks_ hits from LOH to GLH with remap_seed_hits().
And also copy in tracks from EtaBin* to candidateTracks_, and then remap hits from LOH to GLH with quality_store_tracks() and remap_cand_hits().
W/ ROOT uses root_val()

W/O ROOT is a bit simpler... as we only need to do the copy out tracks from EtaBin* and then remap just candidateTracks_.
This uses quality_output()

N.B.1 Since fittestMPlex at the moment is not "end-to-end" with candidate tracks, we can still use the GLH version of InputTracksAndHits()
N.B.2 Since we inflate LOH by 2% more than GLH, hit indices in building only go to GLH, so all loops are sized to GLH.

==========================================
 G. Extra info on ID and mask assignments
==========================================

*** Originally from Track.cc ***

Three basic quantities determine the track ID: 
 1. matching criterion (50% after seed for *ByLabel(), 75% for other hit matching, or via chi2+dphi)
 2. nCandidateHits found compared nMinHits
 3. findability of reference track (if applicable)

Three outcomes exist for each quantity:
 1. matching criterion
    a. reco track passed the matching criterion in set*TrackIDInfo*(): M
    b. reco track failed the matching criterion in set*TrackIDInfo*(): N
    c. reco track never made it past its seed, so matching selection by hit matching via reference track label does not exist in set*TrackIDInfoByLabel(): N/A
 2. nCandHits compared to nMinHits
    a. reco track has greater than or equal to the min hits requirement (i.e. is long enough): L
    b. reco track has less than the min hits requirement (i.e. short): S
    c. reco track is a pure seed, and calling function is set*TrackIDInfoByLabel(): O, by definition then O also equals S
 3. findability of reference track
    a. reference track is findable (nUniqueLayers >= 8 && pT > 0.5): isF
    b. reference track is NOT findable (nUniqueLayers < 8 || pT < 0.5): unF
    c. reference track does not exist in set*TrackIDInfoByLabel(), or we are using set*TrackIDInfo(): ?

mcTrackID assignments 
ID >=   0 : a long reco track is matched to a findable sim/cmssw track: M,L,isF
ID ==  -1 : a long reco track is a true fake, enter numer and denom of FR: N,L,isF
ID ==  -2 : a short reco track is matched to a findable sim/cmssw track: M,S,isF
ID ==  -3 : a short reco track is matched to an unfindable sim/cmssw track: M,S,unF
ID ==  -4 : a long reco track is matched to an unfindable sim/cmssw track: M,L,unF
ID ==  -5 : a short reco track is unmatched to a findable sim/cmssw track: N,S,isF
ID ==  -6 : a short reco track is unmatched to an unfindable sim/cmssw track: N,S,unF
ID ==  -7 : a long reco track is unmatched to an unfindable sim/cmssw track: N,S,unF
ID ==  -8 : a short reco track is unmatched to a track that may not have a reference or the reference is not give: N,S,?
ID ==  -9 : a long reco track is unmatched to a track that may not have a reference or the reference is not give: N,L,?
ID == -10 : a pure seed cannot determine its reference track: N/A,O,?
ID == -11 : a pure seed has a findable reference track: N/A,O,isF
ID == -12 : a pure seed has an unfindable reference track: N/A,O,unF
ID == -13 : a zero size track, protection inside setMCTrackIDInfo(). This should never happen...

N.B. CMSSW TrackID uses same assignments!

*** Originally from TTreeValidation.cc ***

mcTrackID assignments in Track.cc

_[reco] = {seed,build,fit}

N.B. Mask assignments

Logic is as follows: any negative integer means that track is excluded from both the numerator and denominator. A mask with a value greater than 1 means that the track is included in the denominator, but not the numerator.

--> mcmask_[reco] == 1,"associated" reco to sim track [possible duplmask_[reco] == 1,0] {eff and FR}, enter numer and denom of eff, enter denom only of FR
--> mcmask_[reco] == 0,"unassociated" reco to sim track. by definition no duplicates (no reco to associate to sim tracks!) [possible duplmask_[reco] == -1 {eff and FR}], enter denom only of eff, enter numer and denom of FR
--> mcmask_[reco] == -1, sim or reco track excluded from denominator (and therefore numerator) [possible duplmask_[reco] == -1] {eff and FR}
--> mcmask_[reco] == -2, reco track excluded from denominator because it does not exist (and therefore numerator) [possible duplmask_[reco] == -2] {FR}
--> mcmask_[reco] == 2, reco track included in demoninator of FR, but will not enter numerator: for short "matched" tracks {FR only}

--> nTkMatches_[reco] > 1,   n reco tracks associated to the same sim track ID {eff only}
--> nTkMatches_[reco] == 1,  1 reco track associated to single sim track ID {eff only}
--> nTkMatches_[reco] == -99, no reco to sim match {eff only}

excluding position variables, as position could be -99!
--> reco var == -99, "unassociated" reco to sim track [possible mcmask_[reco] == 0,-1,2; possible duplmask_[reco] == -1] {eff only}
--> sim  var == -99, "unassociated" reco to sim track [possible mcmask_[reco] == 0,-1,2; possible duplmask_[reco] == -1] {FR only}
--> reco/sim var == -100, "no matching seed to build/fit" track, fill all reco/sim variables -100 [possible mcmask_[reco] == -1, possible duplmask_[reco] == -1] {FR only}
--> sim  var == -101, reco track is "associated" to sim track, however, sim track does have a hit on the layer the reco track is on

--> seedmask_[reco] == 1, matching seed to reco/fit track [possible mcmask_[reco] == 0,1,2; possible duplmask_[reco] == 0,1,-1] {FR only}
--> seedmask_[reco] == 0, no matching seed to reco/fit track [possible mcmask_[reco] == -2; possible duplmask_[reco] == -2] {FR only}

--> duplmask_[reco] == 0, only "associated" reco to sim track [possible mcmask_[reco] == 1] {eff and FR}
--> duplmask_[reco] == 1, more than one "associated" reco to sim track [possible mcmask_[reco] == 1] {eff and FR}
--> duplmask_[reco] == -1, no "associated" reco to sim track [possible mcmask_[reco] == 0,-1,-2] {eff and FR}
--> duplmask_[reco] == -2, no matching built/fit track for given seed [possible mcmask_[reco] == -2] {FR only}

--> reco var == -10, variable not yet implemented for given track object

position reco variables
--> layers_[reco]    ==  -1, reco unassociated to sim tk {eff only}
--> reco pos+err var == -2000, reco tk is unassociated to sim tk {eff only}
--> reco pos+err var == -3000, reco tk is unassociated to seed tk {FR only}

======================================
 H. Special note about duplicate rate
======================================

*** Originally from PlotValidation.cpp ***

Currently, TEfficiency does not allow you to fill a weighted number in the numerator and NOT the denominator.
In other words, we cannot fill numerator n-1 times sim track is matched, while denominator is just filled once.
As a result, DR is simply if a sim track is duplicated once, and not how many times it is duplicated. 

We can revert back to the n-1 filling for the numerator to weight by the amount of times a sim track is duplicated, but this would mean going back to the TH1Fs, and then using the binomial errors (or computing by hand the CP errors or something), in the case that the DR in any bin > 1... This would break the flow of the printouts as well as the stacking macro, but could be done with some mild pain.

======================
 I. The use of label_
======================

*** Originally from Issue #99 on https://github.com/cerati/mictest ***

## Introduction

The label currently has multiple meanings depending on the type of track and where it is in the pipeline between seeding, building, and validation.  To begin, allow me to map out the differences in inputs for the various validation sequences, and the associated track associator function:

1. ToyMC Geom + sim seeds: setMCTrackIDInfoByLabel()
2. CMSSW Geom + sim seeds (--geom CMS-2017): setMCTrackIDInfoByLabel()
3. ToyMC Geom + found seeds (--find-seeds): setMCTrackIDInfo()
4. CMSSW Geom + cmssw seeds (--geom CMS-2017 --cmssw-seeds --clean-seeds): setMCTrackIDInfo()
5. CMSSW Geom + cmssw seeds + external CMSSW tracks as reference + N^2 cleaning (--geom CMS-2017 --cmssw-seeds --clean-seeds): setCMSSWTrackIDInfo()
5. CMSSW Geom + cmssw seeds + external CMSSW tracks as reference (--geom CMS-2017 --cmssw-seeds): setCMSSWTrackIDInfoByLabel()

## Important note about hits and relation to the label:
As a reminder, all hits that originate from a simulated particle will have a **mcHitID_** >= 0.  This is the index to the vector of simHitInfo_, where each element of the vector contains additional information about the hit.  Most importantly, it stores the **mcTrackID_**  that the hit originated from.  

As such, the following must be respected for the tracks inside simTracks_: **label_** == **mcTrackID_** == **position** inside the track vector.  If the simTracks_ are moved, shuffled, sorted, deleted, etc., this means that the matching of candidate tracks via **mcTrackID_'s** via hits via **mcHitID_** will be ruined!

## Case 1. and 2.: setMCTrackIDInfoByLabel()

In both 1. and 2., the seeds are generated from the simtracks, and as such their **label_** == **mcTrackID_**.  Before the building starts, the seeds can be moved around and into different structures. Regardless, for each seed, a candidate track is created with its **label_** equal to the **label_** of the seed it originated from. At the end of building, the candidate tracks are dumped into their conventional candidateTracks_ collection.  At this point, the **label_** of the track may not be pointing to its **position** inside the vector, but still uniquely identifies it as to which seed it came from.  

So we then create a TrackExtra for the track, storing the **label_** as the **seedID**, and then reassign the **label_** of track to be its **position** inside the candidate track vector.  We actually do this for the seed and fit tracks also.  Each track collection has an associated track extra collection, indexed the same such that candidateTracks_[i] has an associated candidateTracksExtra_[i].

The associator is run for each candidate track, using the fact that the now stored **seedID_** also points to the correct **mcTrackID_** this candidate was created from, counting the number of hits in the candidate track after the seed matching this id.  If more than 50% are matched, the candidate track now sets its track extra **mcTrackID_** == **seedID_**.

We then produce two maps to map the candidate tracks:
1. simToCandidates: 
 - map key = **mcTrackID**
 - mapped value = vector of candidate track **label_'s**, where the **label_'s** now represent the **positions** in the candidate vector for tracks who have the **mcTrackID_** in question

2. seedToCandidates:
 - map key = **seedID_**
 - mapped value = **label_** of candidate track (again, the **label_** now being the **position** inside the track vector)

These maps are then used to get the associated sim and reco information for the trees.

## Case 3. and 4.: setMCTrackIDInfo()

In both 3. and 4., the seedTracks are not intrinsically related to the simTracks_ .  For 3., the seeds are generated from find_seeds(), and the **label_** assigned to the track is just the index at which the seed was created.  For 4., the **label_** is the **mcTrackID** for the sim track it is most closely assocaited to (as given to us from CMSSW), if it exists. 

If using 4., we do relabeling prior to seed cleaning. If **label_** >= 0, the label stays the same, and becomes its **seedID_**.  In the case of the N^2 cleaning, some seeds may remain which have a **label_** == -1.  Since there might be more than one and we want to uniquely identify them after building, we reassign the **label_'s** with an increasing negative number. So the first seed track with **label_** == -1 has label == -1, the second track with **label_** == -1 then has a new **label_* == -2, third track assigned to == -3, etc.  This can also occur in the pure CMSSW seeds (i.e. cmssw seeds that turn into cmssw reco tracks in the cmsswTracks_ collection), in which case we do the relabling in the same fashion.  The CMSSW seeds are then read in and cleaned.  

It is clear here that **label_** of the seed track does not have to equal the **position** inside the track vector!  So the building proceeds in the same manner as 1. and 2., where each seed first generates a single candidate track with a **label_** equal to the seed **label_** which happens to be its **seedID_**.  The candidateTracks_ are dumped out in some order, where the **label_** is still the **seedID_**.

We then generate a TrackExtra for each candidate track (and seed and fit tracks), with the **seedID_** set to the **label_**, then reassigning the **label_** to be the **position** inside the track vector.

The associator is run, now just counting how many hits on the candidate track are matched to a single **mcTrackID**.  If the fraction of hits matching a single **mcTrackID** is greater than 75%, then the track extra **mcTrackID_** is set to the matched **mcTrackID**.

The associate maps are then used in the same fashion as described above. 

## Case 5.: setCMSSWTrackIDInfoByTrkParam()

The seed cleaning and labeling is the same as described for 4. The only difference now is that we run a special sequence before the seeds cleaned and then are sorted in eta, storing the original index position of the seed track as a mapped value of the seed track label.  This is because we wish to keep track of which cmssw track originates from which seed track, and the matching is such that the cmssw track label (before being reassigned to its position) == seedID of the track, which equals the position of a seed track inside the track vector. Not all seed tracks will have this property, as not all seeds become cmssw tracks.

The building proceeds, tracks are dumped out, track extra **seedID_** are set to the track candidate **label_**, and the **label_** is reassigned to the track's **position** inside the vector. We also take the chance to generate a track extra for the CMSSW tracks, storing the **label_** as the **seedID_**, and reassigning the **label_** to the CMSSW track's position inside the cmsswTracks_ vector.  

Afterwards, we set the **mcTrackID** of the candidate track == **seedID** (as described previously). In addition, if the candidate track **label_** is mapped, then we set the **seedID_** == mapped value (i.e. the seedID of the cmssw track before it was realigned --> the position of the seed track in its vector before it was moved in eta bins).  

The candidate track to CMSSW associator is run, matching by chi2 and dphi.  If track finds at least one CMSSW track with a match, the **cmsswTrackID_** is set to the **label_** of the CMSSW track.  We then produce a map of the CMSSW tracks to the candidate mkFit tracks.

cmsswToCandidates: 
 - map key = **cmsswTrackID** (which is now the position of a cmssw track in cmsswTracks_)
 - mapped value = vector of candidate track **label_'s**, where the **label_'s** now represent the **positions** in the candidate vector for tracks who have the **cmsswTrackID_** in question

## Case 6.: setCMSSWTrackIDInfoByLabel()

Can only be used with PURE SEEDS. The meaning of the label here is still the same case 5.  Now, of course, we have a "pure" efficiency denominator made of all the CMSSW reco tracks. A matched is considered if mkFit track shares 50% of its hits after the seed with the CMSSW track it was supposed to matched (i.e. pure seeds).

## Case 7.: setCMSSWTrackIDInfoByHits()

Use only with CMSSW validation: counts how many hits from mkFit track are matched to cmssw with a map for labels, as CMSSW tracks can share hits! Then loop over map, storing labels in  vec that have 75% of hits matched to single CMSSW track (denom is mkFit track nHits).  Then sort by matched CMSSW tracks for each mkFit track, selecting the one with the highest match.
